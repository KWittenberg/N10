@page "/admin/movies"
@attribute [Authorize(Roles = "Admin")]
@implements IAsyncDisposable

@inject IDbContextFactory<ApplicationDbContext> ContextFactory
@inject MovieService MovieService
@inject ITmdbService TmdbService


<title>@Title</title>

<_PageHeader Title="@Title" />

<!-- DIAGNOSTICS BAR -->
<div class="mt-3 @App?.GetContentClass() alert alert-info p-1 small d-flex justify-content-between">
    <span>
        <strong>App Memory:</strong> @(GC.GetTotalMemory(false) / 1024 / 1024) MB
    </span>
    <span>
        <strong>Scan Time:</strong> @(scanDuration / 1000.0) s
    </span>
    <span>
        <strong>RAM Items (New):</strong> @(Movies?.Count ?? 0)
        @if (Movies?.Count > 0)
        {
            <span class="text-muted"> (@EstimateSize(Movies.Count) KB)</span>
        }
    </span>
    <span>
        <strong>DB Items (Total):</strong> @TotalDbItems
    </span>
</div>


<!-- Scan - Populate - Search -->
@if (Entity is null)
{
    <div class="mt-4 p-2 @App?.GetContentClass()">
        <div class="row align-items-center">
            <div class="col-12 col-md-6">
                <button type="button" class="btn btn-primary rounded-pill btn-sm" @onclick="ScanAsync">Scan</button>
                @if (Movies is not null && Movies.Any())
                {
                    <button type="button" class="ms-2 btn btn-primary rounded-pill btn-sm" @onclick="AddAllToDbAsync">Add All To db</button>
                }
                @if (Entities is not null && Entities.Any())
                {
                    <button type="button" class="ms-2 btn btn-primary rounded-pill btn-sm" @onclick="PopulateFromTmdb">Populate From Tmdb</button>
                }
            </div>

            <div class="col-12 col-md-6">
                <EditForm Enhance Model=@SearchTmdb OnValidSubmit=@HandleValidSubmit>
                    <div class="input-group">
                        <InputText class="form-control" @bind-Value="SearchTmdb" placeholder=" search tmdb.." required />
                        <button class="btn btn-primary" type="submit">Search</button>
                    </div>
                </EditForm>
            </div>
        </div>
    </div>
}

<!-- Form -->
@if (Entity is not null)
{
    <_Form Entity="Entity" OnBack="() => Entity = null" />
}
<!-- Table -->
@if (IsProcessing)
{
    <_Loading Title="Please Scan to populate the database!"
              Subtitle="@($"Scaning Folder: {ScanPath}")"
              ButtonText="Scan" OnClick="ScanAsync" />
}
else
{
    @if (TmdbSearch is null && TmdbDetails is null && Entity is null)
    {
        <div class="mt-3 @App?.GetContentClass()">
            @if (Movies is not null && Movies.Any())
            {
                <_Table Entities="Movies.Select(s => s.ToMovieEntity()).AsQueryable()"
                        EntityName="Scan"
                        OnTmdbSearch="HandleSearch"
                        OnLoadEntities="RefreshEntities"
                        OnAddToDb="AddToDbAsync"
                        OnEdit="AddEdit" />
            }
            @if (Entities is not null)
            {
                <_Table Entities="Entities" EntityName="@Title" OnLoadEntities="RefreshEntities" OnEdit="AddEdit" OnPopulate="PopulateFromTmdbById" />
            }
        </div>
    }
}
<!-- SearchCard -->
@if (TmdbSearch is not null)
{
    <div class="mt-5 @App?.GetContentClass()">
        <div class="m-3 d-flex justify-content-start align-items-center" style="cursor: pointer;" @onclick="() => TmdbSearch = null">
            <button type="button" class="btn-close me-2"></button>Close Search
        </div>

        @foreach (var movie in TmdbSearch.Results)
        {
            <_SearchCard Entity="movie" />
        }
    </div>
}

<!-- DetailsCard -->
@if (TmdbDetails is not null)
{
    <div class="mt-5 @App?.GetContentClass()">
        <div class="m-3 d-flex justify-content-start align-items-center" style="cursor: pointer;" @onclick="() => TmdbDetails = null">
            <button type="button" class="btn-close me-2"></button>Close Details
        </div>
        <_DetailsCard Entity="TmdbDetails" />
    </div>
}



@code {
    [CascadingParameter] AppState? App { get; set; }

    // Context koji živi dokle god je komponenta živa - služi SAMO za QuickGrid (Read)
    ApplicationDbContext? ReadContext;

    List<ScanMovieModel>? Movies;
    IQueryable<Movie>? Entities;
    Movie? Entity;
    string? Search;

    string SearchTmdb = string.Empty;
    TmdbSearchList? TmdbSearch;
    TmdbDetails? TmdbDetails;

    const string Title = "Movies";
    bool IsProcessing { get; set; } = true;
    //bool IsEditing { get; set; } = false;

    string ScanPath => Globals.X265Path;

    bool IsScanMode => Movies != null;
    long scanDuration = 0;
    int TotalDbItems = 0;

    // Helper za procjenu veličine (cca 1KB po filmu s metadatom)
    string EstimateSize(int count) => (count * 1.5).ToString("N0");
    // int EstimateSize(int itemCount)
    // {
    //     // Procjena veličine u KB (pretpostavka: svaki objekt zauzima oko 500 bytes)
    //     return (itemCount * 500) / 1024;
    // }

    protected override void OnInitialized()
    {
        // Kreiramo context specifično za ovu komponentu
        ReadContext = ContextFactory.CreateDbContext();
        RefreshEntities();
    }

    // Ovu metodu više ne moraš zvati 'Async' jer je definiranje Query-a sinhrono
    void RefreshEntities()
    {
        // Čišćenje Scan moda
        Movies = null;

        // 1. Koristimo ReadContext
        // 2. AsNoTracking() je ključan za Read-Only gridove (brže je i manje problema)
        Entities = ReadContext!.Movies.AsNoTracking().OrderByDescending(x => x.FileCreatedUtc).AsQueryable();

        // Provjera da li ima podataka (oprez: Any() okinut će upit na bazu)
        if (!ReadContext.Movies.Any())
        {
            App!.ShowToast($"{Title} Not Found!", "error");
            // Nemoj postavljati Entities na null ako želiš da Grid ostane renderiran,
            // ali ako je to tvoja logika, ok:
            Entities = null;
        }

        // Okinemo Count samo JEDNOM kod osvježavanja, a ne u HTML-u
        TotalDbItems = ReadContext.Movies.Count();

        IsProcessing = false;
    }

    // protected override async Task OnInitializedAsync() => await RefreshEntitiesAsync();

    // async Task RefreshEntitiesAsync()
    // {
    //     await using var context = ContextFactory.CreateDbContext();
    //     Entities = context.Movies.AsNoTracking().OrderByDescending(x => x.FileCreatedUtc).AsQueryable();

    //     if (!Entities.Any())
    //     {
    //         await App!.ShowToast($"{Title} Not Found!", "error");
    //         Entities = null;
    //         return;
    //     }

    //     IsProcessing = false;
    // }

    async Task HandleValidSubmit()
    {
        ArgumentNullException.ThrowIfNull(SearchTmdb);

        TmdbSearch = await TmdbService.SearchMoviesAsync(SearchTmdb);

        SearchTmdb = string.Empty;
        StateHasChanged();
    }

    async Task HandleSearch((int? tmdbId, string search, int? year) data)
    {
        if (data.tmdbId.HasValue) TmdbDetails = await TmdbService.GetMovieByIdAsync(data.tmdbId.Value);
        else TmdbSearch = await TmdbService.SearchMoviesAsync(data.search, data.year.ToString());

        SearchTmdb = string.Empty;
        StateHasChanged();
    }

    async Task AddEdit(Movie? input)
    {
        Entity = input;
        await Task.CompletedTask;
    }

    async Task ScanAsync()
    {
        await App!.ShowToast($"Scanning for new movies...", "info");
        // IsProcessing = true;
        var sw = System.Diagnostics.Stopwatch.StartNew();
        
        // 1. Dohvati postojeće nazive iz baze (samo stringovi, brzo)
        HashSet<string> existingFileNames;
        await using (var context = await ContextFactory.CreateDbContextAsync())
        {
            existingFileNames = await context.Movies.AsNoTracking().Select(m => m.FileName).ToHashSetAsync(StringComparer.OrdinalIgnoreCase);
        }

        // 2. Pozovi optimizirani servis
        // Servis će parsirati SAMO one fajlove koji nisu u ovom HashSetu
        Movies = await MovieService.GetNewMoviesOnlyAsync(ScanPath, existingFileNames);

        sw.Stop();
        scanDuration = sw.ElapsedMilliseconds;

        if (Movies.Count > 0)
        {
            await App!.ShowToast($"Found: {Movies.Count} new movies in {scanDuration}ms!", "success");
        }
        else
        {
            await App!.ShowToast($"No new movies found. (Check took {scanDuration}ms)", "info");
            // Opcionalno: Movies = null;
        }

        IsProcessing = false;
    }

    // async Task ScanAsync()
    // {
    //     IsProcessing = true;
    //     var sw = System.Diagnostics.Stopwatch.StartNew();


    //     await App!.ShowToast($"Scaning For New Movies!", "success");
    //     var scannedMovies = await MovieService.GetAllMoviesInFolderAsync(ScanPath);
    //     if (scannedMovies.Count > 0)
    //     {
    //         if (Entities is not null && await Entities.AnyAsync())
    //         {
    //             var existingFileNames = await Entities.Select(m => m.FileName.ToLower()).ToHashSetAsync();
    //             Movies = scannedMovies.Where(m => !existingFileNames.Contains(m.FileName.ToLowerInvariant())).ToList();
    //             if (Movies.Count == 0)
    //             {
    //                 await App!.ShowToast($"No New {Title}!", "info");
    //                 return;
    //             }
    //             await App!.ShowToast($"Found: {Movies.Count} movies!", "success");
    //         }
    //         else
    //         {
    //             Movies = scannedMovies;
    //             await App!.ShowToast($"Found: {scannedMovies.Count} movies!", "info");
    //         }
    //         IsProcessing = false;
    //     }
    //     else await App!.ShowToast($"{Title} Not Found!", "error");

    //     sw.Stop();
    //     scanDuration = sw.ElapsedMilliseconds;
    // }


    // ✅ PISANJE U BAZU - Koristimo kratkotrajni context

    async Task AddToDbAsync(Movie input)
    {
        try
        {
            await using var context = await ContextFactory.CreateDbContextAsync();
            context.Movies.Add(input);
            await context.SaveChangesAsync();
            await App!.ShowToast($"{input.Title} added to database!", "success");

            // Ažuriraj listu skeniranih filmova (in-memory)
            var movieToRemove = Movies?.FirstOrDefault(m => m.FileName == input.FileName);
            if (movieToRemove is not null) Movies?.Remove(movieToRemove);
            // Osvježi Grid - pošto koristimo AsNoTracking u gridu,
            // samo trebamo javiti Blazoru da se nešto promijenilo.
            // QuickGrid će sam povući nove podatke iz baze kod idućeg rendera.
            StateHasChanged();

            // Ako želiš baš forsirati reset query-a (nije nužno ako je samo refresh):
            // RefreshEntities();
        }
        catch (Exception ex)
        {
            await App!.ShowToast($"Failed to add {input.Title} to database: {ex.Message}", "error");
        }
    }

    async Task AddAllToDbAsync()
    {
        if (Movies is null || Movies.Count == 0)
        {
            await App!.ShowToast($"No New {Title}!", "info");
            return;
        }

        await using var context = await ContextFactory.CreateDbContextAsync();
        foreach (var newMovie in Movies)
        {
            var movie = newMovie.ToMovieEntity();
            await context.Movies.AddAsync(movie);
        }

        await context.SaveChangesAsync();

        await App!.ShowToast($"{Movies.Count} {Title} added to database!", "success");
        Movies = null;
        RefreshEntities();
    }


    async Task PopulateFromTmdb()
    {
        await App!.ShowToast($"Start Populate From Tmdb!", "success");
        await MovieService.PopulateFromTmdbAsync();
        RefreshEntities();
        await App!.ShowToast($"Finish and Add Details in Database!", "success");
    }

    async Task PopulateFromTmdbById(Guid id)
    {
        var result = await MovieService.PopulateFromTmdbByIdAsync(id);
        if (result.Success)
        {
            await App!.ShowToast($"{result.Message}", "success");
            RefreshEntities();
        }
        else await App!.ShowToast($"{result.Message}", "error");
    }


    // Čišćenje ReadContext-a kada korisnik ode sa stranice
    public async ValueTask DisposeAsync()
    {
        if (ReadContext is not null) await ReadContext.DisposeAsync();
    }
}
