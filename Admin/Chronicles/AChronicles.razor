@page "/admin/chronicles"

@inject IDbContextFactory<ApplicationDbContext> contextFactory
@inject ChronicleService Service
@inject AiService AiStudioService

<title>@Title</title>

<_PageHeader Title="@Title" AddButtonText="New" OnAddButtonClick="() => Entity = new Chronicle { Content = string.Empty }" />

@if (Chronicles is null)
{
    <_Loading />
}
else
{
    if (Entity is not null)
    {
        <_Form Entity="Entity" OnBack="() => Entity = null" />
    }
    else
    {
        <div class="mt-3 @App?.GetContentClass()">
            <_Table Chronicles="FiveDays" Title="5 Days" OnEdit="AddEdit" OnDelete="LoadAsync" PaginationState="PaginationState5Days" />
            <_Table Chronicles="Chronicles" Title="@Title" OnEdit="AddEdit" OnDelete="LoadAsync" PaginationState="PaginationStateAll" />
        </div>
    }
}


@code {
    [CascadingParameter] AppState? App { get; set; }

    List<Chronicle>? Chronicles;
    List<Chronicle>? FiveDays;
    Chronicle? Entity;
    
    const string Title = "Chronicle";

    PaginationState PaginationState5Days = new PaginationState { ItemsPerPage = 10 };
    PaginationState PaginationStateAll = new PaginationState { ItemsPerPage = 25 };


    protected override async Task OnInitializedAsync() => await LoadAsync();

    async Task LoadAsync()
    {
        await using var db = await contextFactory.CreateDbContextAsync();

        // 1. Učitamo sve (za sada OK, kasnije ćemo optimizirati)
        Chronicles = await db.Chronicles.AsNoTracking().ToListAsync();

        // 2. Odredimo TOČNO današnji datum u Hrvatskoj
        // (Ovo je bitno jer Azure serveri rade na UTC, pa ti u 23:00 h prikazuju krivi dan)
        var croatiaZone = TimeZoneInfo.FindSystemTimeZoneById("Central European Standard Time");
        var today = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, croatiaZone).Date;

        // 3. Računamo krajnji datum (5 dana od danas)
        var endRange = today.AddDays(5);

        // 4. FILTRIRANJE I SORTIRANJE (The Magic)
        FiveDays = Chronicles
            .Where(c => c.Date.HasValue) // Samo oni koji imaju datum
            .Select(c => new
            {
                Original = c,
                // Izračunaj kad taj rođendan pada "sada" (ove ili iduće godine)
                Occurrence = GetNextOccurrence(c.Date!.Value, today)
            })
            // Filtriraj samo one koji upadaju u raspon
            .Where(x => x.Occurrence >= today && x.Occurrence <= endRange)
            // Sortiraj KRONOLOŠKI (Prvo ono što je danas, pa sutra, pa prekosutra...)
            .OrderBy(x => x.Occurrence)
            // Ako ima više događaja isti dan, sortiraj ih po povijesnoj godini (najstariji prvi)
            .ThenBy(x => x.Original.Year)
            // Vrati natrag u Chronicle objekt
            .Select(x => x.Original)
            .ToList();
    }

    async Task AddEdit(Chronicle? input)
    {
        Entity = input;
        await Task.CompletedTask;
    }


    // Pomoćna funkcija koja računa "slijedeći rođendan"
    DateTime GetNextOccurrence(DateOnly eventDate, DateTime referenceDate)
    {
        try
        {
            // Probamo kreirati datum ove godine
            var next = new DateTime(referenceDate.Year, eventDate.Month, eventDate.Day);

            // Ako je taj datum već prošao (npr. danas je 28.12., a događaj je bio 1.1.),
            // onda nas zanima onaj IDUĆE godine (1.1.2026.)
            if (next < referenceDate)
            {
                next = next.AddYears(1);
            }
            return next;
        }
        catch
        {
            // Ovo hvata 29.2. u neprijestupnoj godini - stavljamo ga na 28.2. ili 1.3.
            // Za potrebe prikaza, nek bude zadnji mogući
            return referenceDate.AddYears(100);
        }
    }
}