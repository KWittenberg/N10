@page "/notes"
@layout FrontLayout
@attribute [Authorize]

@inject NavigationManager Navigation
@inject INoteRepository NoteRepository
@inject INoteFolderRepository NoteFolderRepository

<title>@Title</title>

<_NotePageHeader CurrentFolderId="@CurrentFolderId" CurrentPath="@CurrentPath" OnSelectFolderId="SelectFolderId"
                 Title="@Title" AddButtonText="Add Note" NoteUrl="note" OnAddFolderButtonClick="() => Show = !Show" />

<_NewFolderInputModal Show="Show" ParentFolderId="@CurrentFolderId" OnAddNewFolder="() => SelectFolderId(CurrentFolderId)" />

@if (IsProcessing)
{
    <_Loading />
}
else
{
    <div class="mt-5 @App?.GetContentClass()">
        <div class="row">
            <div class="col-md-2 p-3 bg-transparent20">
                <i class="text-white bi bi-stickies-fill" @onclick="() => SelectFolderId(null)"></i>
                @foreach (var root in RootFolders)
                {
                    <_TreeView Folder="@root" OnChildFolderSelected="SelectFolder" />
                }
            </div>

            <div class="col-md-10">
                <div class="">
                    @if (Entities is not null)
                    {
                        @foreach (var item in Entities)
                        {
                            <_NoteCardItem Item="@item" OnDeleted="() => ShowDelete(item)" />
                        }
                    }
                </div>
            </div>
        </div>
    </div>
}


@code {
    [CascadingParameter] AppState? App { get; set; }

    List<NoteDto>? Entities;

    const string Title = "Notes";

    bool IsProcessing = true;

    bool Show = false;

    bool NoteAscending = true;


    Guid? CurrentFolderId;
    NoteFolderDto? CurrentFolder;
    List<NoteFolderDto> CurrentPath = [];
    List<NoteFolderDto> RootFolders = [];


    #region ---> INITIALIZATION
    protected override async Task OnInitializedAsync()
    {
        await LoadRootFolders();
        await SelectFolderId(null);
        IsProcessing = false;
    }

    async Task LoadRootFolders()
    {
        var rootResult = await NoteFolderRepository.GetSubFoldersInCurrentFolderAsync(App?.CurrentUser?.Id, null);
        if (rootResult.Success && rootResult.Data != null) RootFolders = rootResult.Data;
        else RootFolders = [];
    }

    async Task SelectFolderId(Guid? folderId)
    {
        CurrentFolderId = folderId;

        var notesResult = await NoteRepository.GetNotesInCurrentFolderAsync(App?.CurrentUser?.Id, CurrentFolderId);
        Entities = notesResult.Success ? notesResult.Data : [];

        if (CurrentFolderId.HasValue && CurrentFolderId != Guid.Empty)
        {
            var pathResult = await NoteFolderRepository.GetPathToFolderAsync(App?.CurrentUser?.Id, CurrentFolderId.Value);
            CurrentPath = pathResult.Success ? pathResult.Data ?? [] : [];
        }
        else CurrentPath = [];

        StateHasChanged();
    }

    async Task SelectFolder(NoteFolderDto folder) => await SelectFolderId(folder.Id);
    #endregion

    #region ---> DELETE
    void ShowDelete(NoteDto input)
    {
        App?.ShowDeleteConfirmation(input.Title.ToString(), input.Id.ToString(), EventCallback.Factory.Create(this, () => ConfirmDelete(input.Id)));
    }

    async Task ConfirmDelete(Guid id)
    {
        var result = await NoteRepository.DeleteAsync(id);
        if (result.Success) await SelectFolderId(CurrentFolderId);

        await App!.ShowToast(result.Message, result.Success ? "success" : "error");
    }
    #endregion

}